// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: settlements.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSettlement = `-- name: CreateSettlement :one
INSERT INTO settlements (
    group_id, type, payer_id, payee_id, amount, currency_code, status,
    payment_method, transaction_reference, notes, created_by, updated_by
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $11)
RETURNING id, group_id, payer_id, payee_id, amount, currency_code, status, payment_method, transaction_reference, paid_at, notes, created_at, created_by, updated_at, updated_by, deleted_at, type
`

type CreateSettlementParams struct {
	GroupID              pgtype.UUID    `json:"group_id"`
	Type                 string         `json:"type"`
	PayerID              pgtype.UUID    `json:"payer_id"`
	PayeeID              pgtype.UUID    `json:"payee_id"`
	Amount               pgtype.Numeric `json:"amount"`
	CurrencyCode         string         `json:"currency_code"`
	Status               string         `json:"status"`
	PaymentMethod        pgtype.Text    `json:"payment_method"`
	TransactionReference pgtype.Text    `json:"transaction_reference"`
	Notes                pgtype.Text    `json:"notes"`
	CreatedBy            pgtype.UUID    `json:"created_by"`
}

func (q *Queries) CreateSettlement(ctx context.Context, arg CreateSettlementParams) (Settlement, error) {
	row := q.db.QueryRow(ctx, createSettlement,
		arg.GroupID,
		arg.Type,
		arg.PayerID,
		arg.PayeeID,
		arg.Amount,
		arg.CurrencyCode,
		arg.Status,
		arg.PaymentMethod,
		arg.TransactionReference,
		arg.Notes,
		arg.CreatedBy,
	)
	var i Settlement
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.PayerID,
		&i.PayeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionReference,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const deleteSettlement = `-- name: DeleteSettlement :exec
UPDATE settlements
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteSettlement(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSettlement, id)
	return err
}

const getSettlementByID = `-- name: GetSettlementByID :one
SELECT id, group_id, payer_id, payee_id, amount, currency_code, status, payment_method, transaction_reference, paid_at, notes, created_at, created_by, updated_at, updated_by, deleted_at, type FROM settlements
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSettlementByID(ctx context.Context, id pgtype.UUID) (Settlement, error) {
	row := q.db.QueryRow(ctx, getSettlementByID, id)
	var i Settlement
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.PayerID,
		&i.PayeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionReference,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const listFriendSettlements = `-- name: ListFriendSettlements :many
SELECT
    s.id,
    s.group_id,
    s.payer_id,
    s.payee_id,
    s.amount,
    s.currency_code,
    s.status,
    s.payment_method,
    s.transaction_reference,
    s.paid_at,
    s.notes,
    s.created_at,
    s.created_by,
    s.updated_at,
    s.updated_by,
    payer.email AS payer_email,
    payer.name AS payer_name,
    payer.avatar_url AS payer_avatar_url,
    payee.email AS payee_email,
    payee.name AS payee_name,
    payee.avatar_url AS payee_avatar_url
FROM settlements s
JOIN users payer ON s.payer_id = payer.id
JOIN users payee ON s.payee_id = payee.id
WHERE s.type = 'friend'
  AND s.group_id IS NULL
  AND ((s.payer_id = $1 AND s.payee_id = $2) OR (s.payer_id = $2 AND s.payee_id = $1))
  AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListFriendSettlementsParams struct {
	PayerID pgtype.UUID `json:"payer_id"`
	PayeeID pgtype.UUID `json:"payee_id"`
}

type ListFriendSettlementsRow struct {
	ID                   pgtype.UUID        `json:"id"`
	GroupID              pgtype.UUID        `json:"group_id"`
	PayerID              pgtype.UUID        `json:"payer_id"`
	PayeeID              pgtype.UUID        `json:"payee_id"`
	Amount               pgtype.Numeric     `json:"amount"`
	CurrencyCode         string             `json:"currency_code"`
	Status               string             `json:"status"`
	PaymentMethod        pgtype.Text        `json:"payment_method"`
	TransactionReference pgtype.Text        `json:"transaction_reference"`
	PaidAt               pgtype.Timestamptz `json:"paid_at"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy            pgtype.UUID        `json:"updated_by"`
	PayerEmail           string             `json:"payer_email"`
	PayerName            pgtype.Text        `json:"payer_name"`
	PayerAvatarUrl       pgtype.Text        `json:"payer_avatar_url"`
	PayeeEmail           string             `json:"payee_email"`
	PayeeName            pgtype.Text        `json:"payee_name"`
	PayeeAvatarUrl       pgtype.Text        `json:"payee_avatar_url"`
}

func (q *Queries) ListFriendSettlements(ctx context.Context, arg ListFriendSettlementsParams) ([]ListFriendSettlementsRow, error) {
	rows, err := q.db.Query(ctx, listFriendSettlements, arg.PayerID, arg.PayeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFriendSettlementsRow{}
	for rows.Next() {
		var i ListFriendSettlementsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.PayerID,
			&i.PayeeID,
			&i.Amount,
			&i.CurrencyCode,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionReference,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.PayerEmail,
			&i.PayerName,
			&i.PayerAvatarUrl,
			&i.PayeeEmail,
			&i.PayeeName,
			&i.PayeeAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettlementsByGroup = `-- name: ListSettlementsByGroup :many
SELECT
    s.id,
    s.group_id,
    s.payer_id,
    s.payee_id,
    s.amount,
    s.currency_code,
    s.status,
    s.payment_method,
    s.transaction_reference,
    s.paid_at,
    s.notes,
    s.created_at,
    s.created_by,
    s.updated_at,
    s.updated_by,
    payer.email AS payer_email,
    payer.name AS payer_name,
    payer.avatar_url AS payer_avatar_url,
    payee.email AS payee_email,
    payee.name AS payee_name,
    payee.avatar_url AS payee_avatar_url
FROM settlements s
JOIN users payer ON s.payer_id = payer.id
JOIN users payee ON s.payee_id = payee.id
WHERE s.group_id = $1 AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListSettlementsByGroupRow struct {
	ID                   pgtype.UUID        `json:"id"`
	GroupID              pgtype.UUID        `json:"group_id"`
	PayerID              pgtype.UUID        `json:"payer_id"`
	PayeeID              pgtype.UUID        `json:"payee_id"`
	Amount               pgtype.Numeric     `json:"amount"`
	CurrencyCode         string             `json:"currency_code"`
	Status               string             `json:"status"`
	PaymentMethod        pgtype.Text        `json:"payment_method"`
	TransactionReference pgtype.Text        `json:"transaction_reference"`
	PaidAt               pgtype.Timestamptz `json:"paid_at"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy            pgtype.UUID        `json:"updated_by"`
	PayerEmail           string             `json:"payer_email"`
	PayerName            pgtype.Text        `json:"payer_name"`
	PayerAvatarUrl       pgtype.Text        `json:"payer_avatar_url"`
	PayeeEmail           string             `json:"payee_email"`
	PayeeName            pgtype.Text        `json:"payee_name"`
	PayeeAvatarUrl       pgtype.Text        `json:"payee_avatar_url"`
}

func (q *Queries) ListSettlementsByGroup(ctx context.Context, groupID pgtype.UUID) ([]ListSettlementsByGroupRow, error) {
	rows, err := q.db.Query(ctx, listSettlementsByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSettlementsByGroupRow{}
	for rows.Next() {
		var i ListSettlementsByGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.PayerID,
			&i.PayeeID,
			&i.Amount,
			&i.CurrencyCode,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionReference,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.PayerEmail,
			&i.PayerName,
			&i.PayerAvatarUrl,
			&i.PayeeEmail,
			&i.PayeeName,
			&i.PayeeAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettlementsByUser = `-- name: ListSettlementsByUser :many
SELECT
    s.id,
    s.group_id,
    s.payer_id,
    s.payee_id,
    s.amount,
    s.currency_code,
    s.status,
    s.payment_method,
    s.transaction_reference,
    s.paid_at,
    s.notes,
    s.created_at,
    s.created_by,
    s.updated_at,
    s.updated_by,
    g.name AS group_name,
    payer.email AS payer_email,
    payer.name AS payer_name,
    payer.avatar_url AS payer_avatar_url,
    payee.email AS payee_email,
    payee.name AS payee_name,
    payee.avatar_url AS payee_avatar_url
FROM settlements s
JOIN groups g ON s.group_id = g.id
JOIN users payer ON s.payer_id = payer.id
JOIN users payee ON s.payee_id = payee.id
WHERE (s.payer_id = $1 OR s.payee_id = $1) AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListSettlementsByUserRow struct {
	ID                   pgtype.UUID        `json:"id"`
	GroupID              pgtype.UUID        `json:"group_id"`
	PayerID              pgtype.UUID        `json:"payer_id"`
	PayeeID              pgtype.UUID        `json:"payee_id"`
	Amount               pgtype.Numeric     `json:"amount"`
	CurrencyCode         string             `json:"currency_code"`
	Status               string             `json:"status"`
	PaymentMethod        pgtype.Text        `json:"payment_method"`
	TransactionReference pgtype.Text        `json:"transaction_reference"`
	PaidAt               pgtype.Timestamptz `json:"paid_at"`
	Notes                pgtype.Text        `json:"notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy            pgtype.UUID        `json:"updated_by"`
	GroupName            string             `json:"group_name"`
	PayerEmail           string             `json:"payer_email"`
	PayerName            pgtype.Text        `json:"payer_name"`
	PayerAvatarUrl       pgtype.Text        `json:"payer_avatar_url"`
	PayeeEmail           string             `json:"payee_email"`
	PayeeName            pgtype.Text        `json:"payee_name"`
	PayeeAvatarUrl       pgtype.Text        `json:"payee_avatar_url"`
}

func (q *Queries) ListSettlementsByUser(ctx context.Context, payerID pgtype.UUID) ([]ListSettlementsByUserRow, error) {
	rows, err := q.db.Query(ctx, listSettlementsByUser, payerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSettlementsByUserRow{}
	for rows.Next() {
		var i ListSettlementsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.PayerID,
			&i.PayeeID,
			&i.Amount,
			&i.CurrencyCode,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionReference,
			&i.PaidAt,
			&i.Notes,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.GroupName,
			&i.PayerEmail,
			&i.PayerName,
			&i.PayerAvatarUrl,
			&i.PayeeEmail,
			&i.PayeeName,
			&i.PayeeAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSettlement = `-- name: UpdateSettlement :one
UPDATE settlements
SET amount = $2,
    currency_code = $3,
    status = $4,
    payment_method = $5,
    transaction_reference = $6,
    notes = $7,
    paid_at = CASE WHEN $4 = 'completed' AND paid_at IS NULL THEN CURRENT_TIMESTAMP ELSE paid_at END,
    updated_at = CURRENT_TIMESTAMP,
    updated_by = $8
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, group_id, payer_id, payee_id, amount, currency_code, status, payment_method, transaction_reference, paid_at, notes, created_at, created_by, updated_at, updated_by, deleted_at, type
`

type UpdateSettlementParams struct {
	ID                   pgtype.UUID    `json:"id"`
	Amount               pgtype.Numeric `json:"amount"`
	CurrencyCode         string         `json:"currency_code"`
	Status               string         `json:"status"`
	PaymentMethod        pgtype.Text    `json:"payment_method"`
	TransactionReference pgtype.Text    `json:"transaction_reference"`
	Notes                pgtype.Text    `json:"notes"`
	UpdatedBy            pgtype.UUID    `json:"updated_by"`
}

func (q *Queries) UpdateSettlement(ctx context.Context, arg UpdateSettlementParams) (Settlement, error) {
	row := q.db.QueryRow(ctx, updateSettlement,
		arg.ID,
		arg.Amount,
		arg.CurrencyCode,
		arg.Status,
		arg.PaymentMethod,
		arg.TransactionReference,
		arg.Notes,
		arg.UpdatedBy,
	)
	var i Settlement
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.PayerID,
		&i.PayeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionReference,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const updateSettlementStatus = `-- name: UpdateSettlementStatus :one
UPDATE settlements
SET status = $2,
    paid_at = CASE WHEN $2 = 'completed' AND paid_at IS NULL THEN CURRENT_TIMESTAMP ELSE paid_at END,
    updated_at = CURRENT_TIMESTAMP,
    updated_by = $3
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, group_id, payer_id, payee_id, amount, currency_code, status, payment_method, transaction_reference, paid_at, notes, created_at, created_by, updated_at, updated_by, deleted_at, type
`

type UpdateSettlementStatusParams struct {
	ID        pgtype.UUID `json:"id"`
	Status    string      `json:"status"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

func (q *Queries) UpdateSettlementStatus(ctx context.Context, arg UpdateSettlementStatusParams) (Settlement, error) {
	row := q.db.QueryRow(ctx, updateSettlementStatus, arg.ID, arg.Status, arg.UpdatedBy)
	var i Settlement
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.PayerID,
		&i.PayeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionReference,
		&i.PaidAt,
		&i.Notes,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}
