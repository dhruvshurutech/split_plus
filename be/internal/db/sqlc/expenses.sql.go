// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: expenses.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (group_id, type, title, notes, amount, currency_code, date, category_id, tags, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $10) RETURNING id, group_id, title, notes, amount, currency_code, date, created_at, created_by, updated_at, updated_by, deleted_at, type, category_id, tags
`

type CreateExpenseParams struct {
	GroupID      pgtype.UUID    `json:"group_id"`
	Type         string         `json:"type"`
	Title        string         `json:"title"`
	Notes        pgtype.Text    `json:"notes"`
	Amount       pgtype.Numeric `json:"amount"`
	CurrencyCode string         `json:"currency_code"`
	Date         pgtype.Date    `json:"date"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	Tags         []string       `json:"tags"`
	CreatedBy    pgtype.UUID    `json:"created_by"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRow(ctx, createExpense,
		arg.GroupID,
		arg.Type,
		arg.Title,
		arg.Notes,
		arg.Amount,
		arg.CurrencyCode,
		arg.Date,
		arg.CategoryID,
		arg.Tags,
		arg.CreatedBy,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.Date,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.Type,
		&i.CategoryID,
		&i.Tags,
	)
	return i, err
}

const createExpensePayment = `-- name: CreateExpensePayment :one
INSERT INTO expense_payments (expense_id, user_id, pending_user_id, amount, payment_method)
VALUES ($1, $2, $3, $4, $5) RETURNING id, expense_id, user_id, amount, payment_method, created_at, updated_at, deleted_at, pending_user_id
`

type CreateExpensePaymentParams struct {
	ExpenseID     pgtype.UUID    `json:"expense_id"`
	UserID        pgtype.UUID    `json:"user_id"`
	PendingUserID pgtype.UUID    `json:"pending_user_id"`
	Amount        pgtype.Numeric `json:"amount"`
	PaymentMethod pgtype.Text    `json:"payment_method"`
}

func (q *Queries) CreateExpensePayment(ctx context.Context, arg CreateExpensePaymentParams) (ExpensePayment, error) {
	row := q.db.QueryRow(ctx, createExpensePayment,
		arg.ExpenseID,
		arg.UserID,
		arg.PendingUserID,
		arg.Amount,
		arg.PaymentMethod,
	)
	var i ExpensePayment
	err := row.Scan(
		&i.ID,
		&i.ExpenseID,
		&i.UserID,
		&i.Amount,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PendingUserID,
	)
	return i, err
}

const createExpenseSplit = `-- name: CreateExpenseSplit :one
INSERT INTO expense_split (expense_id, user_id, pending_user_id, amount_owned, split_type)
VALUES ($1, $2, $3, $4, $5) RETURNING id, expense_id, user_id, amount_owned, split_type, created_at, updated_at, deleted_at, pending_user_id
`

type CreateExpenseSplitParams struct {
	ExpenseID     pgtype.UUID    `json:"expense_id"`
	UserID        pgtype.UUID    `json:"user_id"`
	PendingUserID pgtype.UUID    `json:"pending_user_id"`
	AmountOwned   pgtype.Numeric `json:"amount_owned"`
	SplitType     string         `json:"split_type"`
}

func (q *Queries) CreateExpenseSplit(ctx context.Context, arg CreateExpenseSplitParams) (ExpenseSplit, error) {
	row := q.db.QueryRow(ctx, createExpenseSplit,
		arg.ExpenseID,
		arg.UserID,
		arg.PendingUserID,
		arg.AmountOwned,
		arg.SplitType,
	)
	var i ExpenseSplit
	err := row.Scan(
		&i.ID,
		&i.ExpenseID,
		&i.UserID,
		&i.AmountOwned,
		&i.SplitType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PendingUserID,
	)
	return i, err
}

const deleteExpense = `-- name: DeleteExpense :exec
UPDATE expenses
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteExpense(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteExpense, id)
	return err
}

const deleteExpensePayments = `-- name: DeleteExpensePayments :exec
UPDATE expense_payments
SET deleted_at = CURRENT_TIMESTAMP
WHERE expense_id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteExpensePayments(ctx context.Context, expenseID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteExpensePayments, expenseID)
	return err
}

const deleteExpenseSplits = `-- name: DeleteExpenseSplits :exec
UPDATE expense_split
SET deleted_at = CURRENT_TIMESTAMP
WHERE expense_id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteExpenseSplits(ctx context.Context, expenseID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteExpenseSplits, expenseID)
	return err
}

const getExpenseByID = `-- name: GetExpenseByID :one
SELECT id, group_id, title, notes, amount, currency_code, date, created_at, created_by, updated_at, updated_by, deleted_at, type, category_id, tags FROM expenses
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetExpenseByID(ctx context.Context, id pgtype.UUID) (Expense, error) {
	row := q.db.QueryRow(ctx, getExpenseByID, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.Date,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.Type,
		&i.CategoryID,
		&i.Tags,
	)
	return i, err
}

const listExpensePayments = `-- name: ListExpensePayments :many
SELECT
    ep.id,
    ep.expense_id,
    ep.user_id,
    ep.pending_user_id,
    ep.amount,
    ep.payment_method,
    ep.created_at,
    ep.updated_at,
    u.email AS user_email,
    u.name AS user_name,
    u.avatar_url AS user_avatar_url,
    pu.email AS pending_user_email,
    pu.name AS pending_user_name
FROM expense_payments ep
LEFT JOIN users u ON ep.user_id = u.id
LEFT JOIN pending_users pu ON ep.pending_user_id = pu.id
WHERE ep.expense_id = $1 AND ep.deleted_at IS NULL
ORDER BY ep.created_at ASC
`

type ListExpensePaymentsRow struct {
	ID               pgtype.UUID        `json:"id"`
	ExpenseID        pgtype.UUID        `json:"expense_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	PendingUserID    pgtype.UUID        `json:"pending_user_id"`
	Amount           pgtype.Numeric     `json:"amount"`
	PaymentMethod    pgtype.Text        `json:"payment_method"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	UserEmail        pgtype.Text        `json:"user_email"`
	UserName         pgtype.Text        `json:"user_name"`
	UserAvatarUrl    pgtype.Text        `json:"user_avatar_url"`
	PendingUserEmail pgtype.Text        `json:"pending_user_email"`
	PendingUserName  pgtype.Text        `json:"pending_user_name"`
}

func (q *Queries) ListExpensePayments(ctx context.Context, expenseID pgtype.UUID) ([]ListExpensePaymentsRow, error) {
	rows, err := q.db.Query(ctx, listExpensePayments, expenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpensePaymentsRow{}
	for rows.Next() {
		var i ListExpensePaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExpenseID,
			&i.UserID,
			&i.PendingUserID,
			&i.Amount,
			&i.PaymentMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserEmail,
			&i.UserName,
			&i.UserAvatarUrl,
			&i.PendingUserEmail,
			&i.PendingUserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpenseSplits = `-- name: ListExpenseSplits :many
SELECT
    es.id,
    es.expense_id,
    es.user_id,
    es.pending_user_id,
    es.amount_owned,
    es.split_type,
    es.created_at,
    es.updated_at,
    u.email AS user_email,
    u.name AS user_name,
    u.avatar_url AS user_avatar_url,
    pu.email AS pending_user_email,
    pu.name AS pending_user_name
FROM expense_split es
LEFT JOIN users u ON es.user_id = u.id
LEFT JOIN pending_users pu ON es.pending_user_id = pu.id
WHERE es.expense_id = $1 AND es.deleted_at IS NULL
ORDER BY es.created_at ASC
`

type ListExpenseSplitsRow struct {
	ID               pgtype.UUID        `json:"id"`
	ExpenseID        pgtype.UUID        `json:"expense_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	PendingUserID    pgtype.UUID        `json:"pending_user_id"`
	AmountOwned      pgtype.Numeric     `json:"amount_owned"`
	SplitType        string             `json:"split_type"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	UserEmail        pgtype.Text        `json:"user_email"`
	UserName         pgtype.Text        `json:"user_name"`
	UserAvatarUrl    pgtype.Text        `json:"user_avatar_url"`
	PendingUserEmail pgtype.Text        `json:"pending_user_email"`
	PendingUserName  pgtype.Text        `json:"pending_user_name"`
}

func (q *Queries) ListExpenseSplits(ctx context.Context, expenseID pgtype.UUID) ([]ListExpenseSplitsRow, error) {
	rows, err := q.db.Query(ctx, listExpenseSplits, expenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpenseSplitsRow{}
	for rows.Next() {
		var i ListExpenseSplitsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExpenseID,
			&i.UserID,
			&i.PendingUserID,
			&i.AmountOwned,
			&i.SplitType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserEmail,
			&i.UserName,
			&i.UserAvatarUrl,
			&i.PendingUserEmail,
			&i.PendingUserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpensesByGroup = `-- name: ListExpensesByGroup :many
SELECT id, group_id, title, notes, amount, currency_code, date, created_at, created_by, updated_at, updated_by, deleted_at, type, category_id, tags FROM expenses
WHERE group_id = $1 AND deleted_at IS NULL
ORDER BY date DESC, created_at DESC
`

func (q *Queries) ListExpensesByGroup(ctx context.Context, groupID pgtype.UUID) ([]Expense, error) {
	rows, err := q.db.Query(ctx, listExpensesByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Expense{}
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Title,
			&i.Notes,
			&i.Amount,
			&i.CurrencyCode,
			&i.Date,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.Type,
			&i.CategoryID,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriendExpenses = `-- name: ListFriendExpenses :many
SELECT e.id, e.group_id, e.title, e.notes, e.amount, e.currency_code, e.date, e.created_at, e.created_by, e.updated_at, e.updated_by, e.deleted_at, e.type, e.category_id, e.tags
FROM expenses e
WHERE e.type = 'friend'
  AND e.group_id IS NULL
  AND e.deleted_at IS NULL
  AND EXISTS (
    SELECT 1 FROM expense_payments ep
    WHERE ep.expense_id = e.id
      AND ep.user_id IN ($1, $2)
      AND ep.deleted_at IS NULL
  )
  AND EXISTS (
    SELECT 1 FROM expense_split es
    WHERE es.expense_id = e.id
      AND es.user_id IN ($1, $2)
      AND es.deleted_at IS NULL
  )
  AND NOT EXISTS (
    SELECT 1 FROM expense_payments ep
    WHERE ep.expense_id = e.id
      AND ep.user_id NOT IN ($1, $2)
      AND ep.deleted_at IS NULL
  )
  AND NOT EXISTS (
    SELECT 1 FROM expense_split es
    WHERE es.expense_id = e.id
      AND es.user_id NOT IN ($1, $2)
      AND es.deleted_at IS NULL
  )
ORDER BY e.date DESC, e.created_at DESC
`

type ListFriendExpensesParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	UserID_2 pgtype.UUID `json:"user_id_2"`
}

func (q *Queries) ListFriendExpenses(ctx context.Context, arg ListFriendExpensesParams) ([]Expense, error) {
	rows, err := q.db.Query(ctx, listFriendExpenses, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Expense{}
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Title,
			&i.Notes,
			&i.Amount,
			&i.CurrencyCode,
			&i.Date,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.Type,
			&i.CategoryID,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchExpenses = `-- name: SearchExpenses :many
SELECT e.id, e.group_id, e.title, e.notes, e.amount, e.currency_code, e.date, e.created_at, e.created_by, e.updated_at, e.updated_by, e.deleted_at, e.type, e.category_id, e.tags FROM expenses e
WHERE e.group_id = $1
  AND e.deleted_at IS NULL
  AND (
    $2::text IS NULL OR 
    to_tsvector('english', e.title || ' ' || COALESCE(e.notes, '')) @@ plainto_tsquery('english', $2)
  )
  AND ($3::date IS NULL OR e.date >= $3)
  AND ($4::date IS NULL OR e.date <= $4)
  AND ($5::uuid IS NULL OR e.category_id = $5)
  AND ($6::uuid IS NULL OR e.created_by = $6)
  AND ($7::numeric IS NULL OR e.amount >= $7)
  AND ($8::numeric IS NULL OR e.amount <= $8)
  AND ($9::uuid IS NULL OR EXISTS (
    SELECT 1 FROM expense_payments ep 
    WHERE ep.expense_id = e.id AND ep.user_id = $9 AND ep.deleted_at IS NULL
  ))
  AND ($10::uuid IS NULL OR EXISTS (
    SELECT 1 FROM expense_split es 
    WHERE es.expense_id = e.id AND es.user_id = $10 AND es.deleted_at IS NULL
  ))
ORDER BY e.date DESC, e.created_at DESC
LIMIT $12 OFFSET $11
`

type SearchExpensesParams struct {
	GroupID    pgtype.UUID    `json:"group_id"`
	Query      pgtype.Text    `json:"query"`
	StartDate  pgtype.Date    `json:"start_date"`
	EndDate    pgtype.Date    `json:"end_date"`
	CategoryID pgtype.UUID    `json:"category_id"`
	CreatedBy  pgtype.UUID    `json:"created_by"`
	MinAmount  pgtype.Numeric `json:"min_amount"`
	MaxAmount  pgtype.Numeric `json:"max_amount"`
	PayerID    pgtype.UUID    `json:"payer_id"`
	OwerID     pgtype.UUID    `json:"ower_id"`
	Offset     int32          `json:"offset"`
	Limit      int32          `json:"limit"`
}

func (q *Queries) SearchExpenses(ctx context.Context, arg SearchExpensesParams) ([]Expense, error) {
	rows, err := q.db.Query(ctx, searchExpenses,
		arg.GroupID,
		arg.Query,
		arg.StartDate,
		arg.EndDate,
		arg.CategoryID,
		arg.CreatedBy,
		arg.MinAmount,
		arg.MaxAmount,
		arg.PayerID,
		arg.OwerID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Expense{}
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Title,
			&i.Notes,
			&i.Amount,
			&i.CurrencyCode,
			&i.Date,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.Type,
			&i.CategoryID,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpense = `-- name: UpdateExpense :one
UPDATE expenses
SET title = $2,
    notes = $3,
    amount = $4,
    currency_code = $5,
    date = $6,
    category_id = $7,
    tags = $8,
    updated_by = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, group_id, title, notes, amount, currency_code, date, created_at, created_by, updated_at, updated_by, deleted_at, type, category_id, tags
`

type UpdateExpenseParams struct {
	ID           pgtype.UUID    `json:"id"`
	Title        string         `json:"title"`
	Notes        pgtype.Text    `json:"notes"`
	Amount       pgtype.Numeric `json:"amount"`
	CurrencyCode string         `json:"currency_code"`
	Date         pgtype.Date    `json:"date"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	Tags         []string       `json:"tags"`
	UpdatedBy    pgtype.UUID    `json:"updated_by"`
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRow(ctx, updateExpense,
		arg.ID,
		arg.Title,
		arg.Notes,
		arg.Amount,
		arg.CurrencyCode,
		arg.Date,
		arg.CategoryID,
		arg.Tags,
		arg.UpdatedBy,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.Date,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.Type,
		&i.CategoryID,
		&i.Tags,
	)
	return i, err
}

const updateExpenseSplit = `-- name: UpdateExpenseSplit :one
UPDATE expense_split
SET amount_owned = $3,
    split_type = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE expense_id = $1 AND user_id = $2 AND deleted_at IS NULL
RETURNING id, expense_id, user_id, amount_owned, split_type, created_at, updated_at, deleted_at, pending_user_id
`

type UpdateExpenseSplitParams struct {
	ExpenseID   pgtype.UUID    `json:"expense_id"`
	UserID      pgtype.UUID    `json:"user_id"`
	AmountOwned pgtype.Numeric `json:"amount_owned"`
	SplitType   string         `json:"split_type"`
}

func (q *Queries) UpdateExpenseSplit(ctx context.Context, arg UpdateExpenseSplitParams) (ExpenseSplit, error) {
	row := q.db.QueryRow(ctx, updateExpenseSplit,
		arg.ExpenseID,
		arg.UserID,
		arg.AmountOwned,
		arg.SplitType,
	)
	var i ExpenseSplit
	err := row.Scan(
		&i.ID,
		&i.ExpenseID,
		&i.UserID,
		&i.AmountOwned,
		&i.SplitType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PendingUserID,
	)
	return i, err
}
