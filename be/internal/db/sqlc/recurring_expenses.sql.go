// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recurring_expenses.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecurringExpense = `-- name: CreateRecurringExpense :one
INSERT INTO recurring_expenses (
    group_id, title, notes, amount, currency_code, repeat_interval,
    day_of_month, day_of_week, start_date, end_date, next_occurrence_date,
    is_active, created_by, updated_by
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $13)
RETURNING id, group_id, title, notes, amount, currency_code, repeat_interval, day_of_month, day_of_week, start_date, end_date, next_occurrence_date, is_active, created_at, created_by, updated_at, updated_by, deleted_at
`

type CreateRecurringExpenseParams struct {
	GroupID            pgtype.UUID    `json:"group_id"`
	Title              string         `json:"title"`
	Notes              pgtype.Text    `json:"notes"`
	Amount             pgtype.Numeric `json:"amount"`
	CurrencyCode       string         `json:"currency_code"`
	RepeatInterval     string         `json:"repeat_interval"`
	DayOfMonth         pgtype.Int4    `json:"day_of_month"`
	DayOfWeek          pgtype.Int4    `json:"day_of_week"`
	StartDate          pgtype.Date    `json:"start_date"`
	EndDate            pgtype.Date    `json:"end_date"`
	NextOccurrenceDate pgtype.Date    `json:"next_occurrence_date"`
	IsActive           pgtype.Bool    `json:"is_active"`
	CreatedBy          pgtype.UUID    `json:"created_by"`
}

func (q *Queries) CreateRecurringExpense(ctx context.Context, arg CreateRecurringExpenseParams) (RecurringExpense, error) {
	row := q.db.QueryRow(ctx, createRecurringExpense,
		arg.GroupID,
		arg.Title,
		arg.Notes,
		arg.Amount,
		arg.CurrencyCode,
		arg.RepeatInterval,
		arg.DayOfMonth,
		arg.DayOfWeek,
		arg.StartDate,
		arg.EndDate,
		arg.NextOccurrenceDate,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i RecurringExpense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.RepeatInterval,
		&i.DayOfMonth,
		&i.DayOfWeek,
		&i.StartDate,
		&i.EndDate,
		&i.NextOccurrenceDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}

const createRecurringExpensePayment = `-- name: CreateRecurringExpensePayment :one
INSERT INTO recurring_expense_payments (recurring_expense_id, user_id, amount, payment_method)
VALUES ($1, $2, $3, $4) RETURNING id, recurring_expense_id, user_id, amount, payment_method, created_at, updated_at, deleted_at
`

type CreateRecurringExpensePaymentParams struct {
	RecurringExpenseID pgtype.UUID    `json:"recurring_expense_id"`
	UserID             pgtype.UUID    `json:"user_id"`
	Amount             pgtype.Numeric `json:"amount"`
	PaymentMethod      pgtype.Text    `json:"payment_method"`
}

func (q *Queries) CreateRecurringExpensePayment(ctx context.Context, arg CreateRecurringExpensePaymentParams) (RecurringExpensePayment, error) {
	row := q.db.QueryRow(ctx, createRecurringExpensePayment,
		arg.RecurringExpenseID,
		arg.UserID,
		arg.Amount,
		arg.PaymentMethod,
	)
	var i RecurringExpensePayment
	err := row.Scan(
		&i.ID,
		&i.RecurringExpenseID,
		&i.UserID,
		&i.Amount,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createRecurringExpenseSplit = `-- name: CreateRecurringExpenseSplit :one
INSERT INTO recurring_expense_splits (recurring_expense_id, user_id, amount_owned, split_type)
VALUES ($1, $2, $3, $4) RETURNING id, recurring_expense_id, user_id, amount_owned, split_type, created_at, updated_at, deleted_at
`

type CreateRecurringExpenseSplitParams struct {
	RecurringExpenseID pgtype.UUID    `json:"recurring_expense_id"`
	UserID             pgtype.UUID    `json:"user_id"`
	AmountOwned        pgtype.Numeric `json:"amount_owned"`
	SplitType          string         `json:"split_type"`
}

func (q *Queries) CreateRecurringExpenseSplit(ctx context.Context, arg CreateRecurringExpenseSplitParams) (RecurringExpenseSplit, error) {
	row := q.db.QueryRow(ctx, createRecurringExpenseSplit,
		arg.RecurringExpenseID,
		arg.UserID,
		arg.AmountOwned,
		arg.SplitType,
	)
	var i RecurringExpenseSplit
	err := row.Scan(
		&i.ID,
		&i.RecurringExpenseID,
		&i.UserID,
		&i.AmountOwned,
		&i.SplitType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteRecurringExpense = `-- name: DeleteRecurringExpense :exec
UPDATE recurring_expenses
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteRecurringExpense(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRecurringExpense, id)
	return err
}

const getRecurringExpenseByID = `-- name: GetRecurringExpenseByID :one
SELECT id, group_id, title, notes, amount, currency_code, repeat_interval, day_of_month, day_of_week, start_date, end_date, next_occurrence_date, is_active, created_at, created_by, updated_at, updated_by, deleted_at FROM recurring_expenses
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetRecurringExpenseByID(ctx context.Context, id pgtype.UUID) (RecurringExpense, error) {
	row := q.db.QueryRow(ctx, getRecurringExpenseByID, id)
	var i RecurringExpense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.RepeatInterval,
		&i.DayOfMonth,
		&i.DayOfWeek,
		&i.StartDate,
		&i.EndDate,
		&i.NextOccurrenceDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}

const getRecurringExpensesDue = `-- name: GetRecurringExpensesDue :many
SELECT id, group_id, title, notes, amount, currency_code, repeat_interval, day_of_month, day_of_week, start_date, end_date, next_occurrence_date, is_active, created_at, created_by, updated_at, updated_by, deleted_at FROM recurring_expenses
WHERE is_active = true
    AND deleted_at IS NULL
    AND next_occurrence_date <= CURRENT_DATE
ORDER BY next_occurrence_date ASC
`

func (q *Queries) GetRecurringExpensesDue(ctx context.Context) ([]RecurringExpense, error) {
	rows, err := q.db.Query(ctx, getRecurringExpensesDue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringExpense{}
	for rows.Next() {
		var i RecurringExpense
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Title,
			&i.Notes,
			&i.Amount,
			&i.CurrencyCode,
			&i.RepeatInterval,
			&i.DayOfMonth,
			&i.DayOfWeek,
			&i.StartDate,
			&i.EndDate,
			&i.NextOccurrenceDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringExpensePayments = `-- name: ListRecurringExpensePayments :many
SELECT
    rep.id,
    rep.recurring_expense_id,
    rep.user_id,
    rep.amount,
    rep.payment_method,
    rep.created_at,
    rep.updated_at,
    u.email AS user_email,
    u.name AS user_name,
    u.avatar_url AS user_avatar_url
FROM recurring_expense_payments rep
JOIN users u ON rep.user_id = u.id
WHERE rep.recurring_expense_id = $1 AND rep.deleted_at IS NULL
ORDER BY rep.created_at ASC
`

type ListRecurringExpensePaymentsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	RecurringExpenseID pgtype.UUID        `json:"recurring_expense_id"`
	UserID             pgtype.UUID        `json:"user_id"`
	Amount             pgtype.Numeric     `json:"amount"`
	PaymentMethod      pgtype.Text        `json:"payment_method"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	UserEmail          string             `json:"user_email"`
	UserName           pgtype.Text        `json:"user_name"`
	UserAvatarUrl      pgtype.Text        `json:"user_avatar_url"`
}

func (q *Queries) ListRecurringExpensePayments(ctx context.Context, recurringExpenseID pgtype.UUID) ([]ListRecurringExpensePaymentsRow, error) {
	rows, err := q.db.Query(ctx, listRecurringExpensePayments, recurringExpenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecurringExpensePaymentsRow{}
	for rows.Next() {
		var i ListRecurringExpensePaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.RecurringExpenseID,
			&i.UserID,
			&i.Amount,
			&i.PaymentMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserEmail,
			&i.UserName,
			&i.UserAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringExpenseSplits = `-- name: ListRecurringExpenseSplits :many
SELECT
    res.id,
    res.recurring_expense_id,
    res.user_id,
    res.amount_owned,
    res.split_type,
    res.created_at,
    res.updated_at,
    u.email AS user_email,
    u.name AS user_name,
    u.avatar_url AS user_avatar_url
FROM recurring_expense_splits res
JOIN users u ON res.user_id = u.id
WHERE res.recurring_expense_id = $1 AND res.deleted_at IS NULL
ORDER BY res.created_at ASC
`

type ListRecurringExpenseSplitsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	RecurringExpenseID pgtype.UUID        `json:"recurring_expense_id"`
	UserID             pgtype.UUID        `json:"user_id"`
	AmountOwned        pgtype.Numeric     `json:"amount_owned"`
	SplitType          string             `json:"split_type"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	UserEmail          string             `json:"user_email"`
	UserName           pgtype.Text        `json:"user_name"`
	UserAvatarUrl      pgtype.Text        `json:"user_avatar_url"`
}

func (q *Queries) ListRecurringExpenseSplits(ctx context.Context, recurringExpenseID pgtype.UUID) ([]ListRecurringExpenseSplitsRow, error) {
	rows, err := q.db.Query(ctx, listRecurringExpenseSplits, recurringExpenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecurringExpenseSplitsRow{}
	for rows.Next() {
		var i ListRecurringExpenseSplitsRow
		if err := rows.Scan(
			&i.ID,
			&i.RecurringExpenseID,
			&i.UserID,
			&i.AmountOwned,
			&i.SplitType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserEmail,
			&i.UserName,
			&i.UserAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringExpensesByGroup = `-- name: ListRecurringExpensesByGroup :many
SELECT id, group_id, title, notes, amount, currency_code, repeat_interval, day_of_month, day_of_week, start_date, end_date, next_occurrence_date, is_active, created_at, created_by, updated_at, updated_by, deleted_at FROM recurring_expenses
WHERE group_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListRecurringExpensesByGroup(ctx context.Context, groupID pgtype.UUID) ([]RecurringExpense, error) {
	rows, err := q.db.Query(ctx, listRecurringExpensesByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringExpense{}
	for rows.Next() {
		var i RecurringExpense
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Title,
			&i.Notes,
			&i.Amount,
			&i.CurrencyCode,
			&i.RepeatInterval,
			&i.DayOfMonth,
			&i.DayOfWeek,
			&i.StartDate,
			&i.EndDate,
			&i.NextOccurrenceDate,
			&i.IsActive,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNextOccurrenceDate = `-- name: UpdateNextOccurrenceDate :one
UPDATE recurring_expenses
SET next_occurrence_date = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, group_id, title, notes, amount, currency_code, repeat_interval, day_of_month, day_of_week, start_date, end_date, next_occurrence_date, is_active, created_at, created_by, updated_at, updated_by, deleted_at
`

type UpdateNextOccurrenceDateParams struct {
	ID                 pgtype.UUID `json:"id"`
	NextOccurrenceDate pgtype.Date `json:"next_occurrence_date"`
}

func (q *Queries) UpdateNextOccurrenceDate(ctx context.Context, arg UpdateNextOccurrenceDateParams) (RecurringExpense, error) {
	row := q.db.QueryRow(ctx, updateNextOccurrenceDate, arg.ID, arg.NextOccurrenceDate)
	var i RecurringExpense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.RepeatInterval,
		&i.DayOfMonth,
		&i.DayOfWeek,
		&i.StartDate,
		&i.EndDate,
		&i.NextOccurrenceDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}

const updateRecurringExpense = `-- name: UpdateRecurringExpense :one
UPDATE recurring_expenses
SET title = $2,
    notes = $3,
    amount = $4,
    currency_code = $5,
    repeat_interval = $6,
    day_of_month = $7,
    day_of_week = $8,
    start_date = $9,
    end_date = $10,
    next_occurrence_date = $11,
    is_active = $12,
    updated_by = $13,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, group_id, title, notes, amount, currency_code, repeat_interval, day_of_month, day_of_week, start_date, end_date, next_occurrence_date, is_active, created_at, created_by, updated_at, updated_by, deleted_at
`

type UpdateRecurringExpenseParams struct {
	ID                 pgtype.UUID    `json:"id"`
	Title              string         `json:"title"`
	Notes              pgtype.Text    `json:"notes"`
	Amount             pgtype.Numeric `json:"amount"`
	CurrencyCode       string         `json:"currency_code"`
	RepeatInterval     string         `json:"repeat_interval"`
	DayOfMonth         pgtype.Int4    `json:"day_of_month"`
	DayOfWeek          pgtype.Int4    `json:"day_of_week"`
	StartDate          pgtype.Date    `json:"start_date"`
	EndDate            pgtype.Date    `json:"end_date"`
	NextOccurrenceDate pgtype.Date    `json:"next_occurrence_date"`
	IsActive           pgtype.Bool    `json:"is_active"`
	UpdatedBy          pgtype.UUID    `json:"updated_by"`
}

func (q *Queries) UpdateRecurringExpense(ctx context.Context, arg UpdateRecurringExpenseParams) (RecurringExpense, error) {
	row := q.db.QueryRow(ctx, updateRecurringExpense,
		arg.ID,
		arg.Title,
		arg.Notes,
		arg.Amount,
		arg.CurrencyCode,
		arg.RepeatInterval,
		arg.DayOfMonth,
		arg.DayOfWeek,
		arg.StartDate,
		arg.EndDate,
		arg.NextOccurrenceDate,
		arg.IsActive,
		arg.UpdatedBy,
	)
	var i RecurringExpense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.RepeatInterval,
		&i.DayOfMonth,
		&i.DayOfWeek,
		&i.StartDate,
		&i.EndDate,
		&i.NextOccurrenceDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}

const updateRecurringExpenseActiveStatus = `-- name: UpdateRecurringExpenseActiveStatus :one
UPDATE recurring_expenses
SET is_active = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, group_id, title, notes, amount, currency_code, repeat_interval, day_of_month, day_of_week, start_date, end_date, next_occurrence_date, is_active, created_at, created_by, updated_at, updated_by, deleted_at
`

type UpdateRecurringExpenseActiveStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateRecurringExpenseActiveStatus(ctx context.Context, arg UpdateRecurringExpenseActiveStatusParams) (RecurringExpense, error) {
	row := q.db.QueryRow(ctx, updateRecurringExpenseActiveStatus, arg.ID, arg.IsActive)
	var i RecurringExpense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Title,
		&i.Notes,
		&i.Amount,
		&i.CurrencyCode,
		&i.RepeatInterval,
		&i.DayOfMonth,
		&i.DayOfWeek,
		&i.StartDate,
		&i.EndDate,
		&i.NextOccurrenceDate,
		&i.IsActive,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}
